# 函数



## 模式匹配
在定义函数时，你可以为不同的模式分别定义同一函数，你可以使用模式匹配一切数据类型 --- 数字，字符，List，元组，等等

```haskell
lucky :: (Integral a) => a -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
```

```haskell
factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

使用注意事项:
  - 匹配至上而下，如果前面已经被匹配，后面的函数就不会再被匹配到了
  - 在定义模式时最好在末尾保留一个最全的匹配，以防匹配不到出现错误


### 模式匹配 -参数解构


#### 解构 Tuple（元祖）

只需要将两个参数都写成 Tuple 的形式就会进行参数解构

```haskell
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```


#### 忽略参数 _

_ 就和 List Comprehension 中一样。表示我们不关心这部分的具体内容

```haskell
first :: (a, b, c) -> a
first (x, _, _) = x

second :: (a, b, c) -> b
second (_, y, _) = y

third :: (a, b, c) -> c
third (_, _, z) = z
```


#### List Comprehension（集合） 中使用

```haskell
ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
ghci> [a+b | (a,b) <- xs]
[4,7,6,8,11,4]
```
一旦模式匹配失败，它就简单挪到下个元素。

当然 List 本身也可以使用模式匹配。你可以用 [] 或 : 来匹配它，
因为 [1,2,3] 本质就是 1:2:3:[] 的语法糖, 所以像 x:xs 这样的模式可以将 List 的头部绑定为 x，尾部绑定为 xs

```haskell
head' :: [a] -> a
head' [] = error "Can't call head on an empty list, dummy!"
head' (x:_) = x
```

匹配是必须使用() 括起来， 匹配到 [] 我们返回了一个运行时错误，这会让程序中断退出，酌情使用。

```haskell
length' :: (Num b) => [a] -> b
length' [] = 0
length' (_:xs) = 1 + length' xs
```

> ``x:xs`` 这模式的应用非常广泛，尤其是递归函数。不过要注意的是它只能匹配长度大于等于 1 的 List


#### as -- @

as 就是将一个名字和 @ 置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。如这个模式 xs@(x:y:ys)，它会匹配出与 x:y:ys 对应的东西，同时你也可以方便地通过 xs 得到整个 List，而不必在函数体中重复 x:y:ys

```haskell
capital :: String -> String
capital "" = "Empty string, whoops!"
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]
```



## Guards (守卫)

如果说模式用来检查一个值是否合适并从中取值，那么 guard 则用来检查一个值的某项属性是否为真， 其实就是类似 if 语句。但是它能提高代码的可读性，并且能和模式匹配很好的契合。

先看一个计算 BMI 的函数

```haskell
bmiTell :: (RealFloat a) => a -> String
bmiTell bmi
    | bmi <= 18.5 = "You're underweight, you emo, you!"
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"
    | otherwise   = "You're a whale, congratulations!"
```

