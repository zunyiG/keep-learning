# 函数



## 模式匹配
在定义函数时，你可以为不同的模式分别定义同一函数，你可以使用模式匹配一切数据类型 --- 数字，字符，List，元组，等等

```haskell
lucky :: (Integral a) => a -> String
lucky 7 = "LUCKY NUMBER SEVEN!"
lucky x = "Sorry, you're out of luck, pal!"
```

```haskell
factorial :: (Integral a) => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)
```

使用注意事项:
  - 匹配至上而下，如果前面已经被匹配，后面的函数就不会再被匹配到了
  - 在定义模式时最好在末尾保留一个最全的匹配，以防匹配不到出现错误


### 参数解构


#### 解构 Tuple（元祖）

只需要将两个参数都写成 Tuple 的形式就会进行参数解构

```haskell
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
```


#### 忽略参数 _

_ 就和 List Comprehension 中一样。表示我们不关心这部分的具体内容

```haskell
first :: (a, b, c) -> a
first (x, _, _) = x

second :: (a, b, c) -> b
second (_, y, _) = y

third :: (a, b, c) -> c
third (_, _, z) = z
```


#### List Comprehension（集合） 中使用

```haskell
ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
ghci> [a+b | (a,b) <- xs]
[4,7,6,8,11,4]
```
一旦模式匹配失败，它就简单挪到下个元素。

当然 List 本身也可以使用模式匹配。你可以用 [] 或 : 来匹配它，
因为 [1,2,3] 本质就是 1:2:3:[] 的语法糖。
