# 模块

## 加载模块

haskell 中使用 `import` 来加载模块，一般定义在代码顶部。
> Prelude 是haskell标准库的一组模块，它缺省自动加载

``` haskell
import Data.List  

numUniques :: (Eq a) => [a] -> Int  
numUniques = length . nub
```

也可以在ghci中使用 :m 加载模块

```haskell
ghci> :m Data.List Data.Map Data.Set
```

部分引入

```haskell
import Data.List (nub, sort)
```

除去部分函数引入其它部分

```haskell
import Data.List hiding (nub)
```

为避免命名冲突，可以有限制的引入, 同时为了使用简单可以加上别名

```haskell
import qualified Data.Map
-- 使用 Data.map.filter

import qualified Data.Map as M
-- 使用 M.filter
```

## Data.List

该主要是用来操作 list 的， 如之前使用过的map 和 filter 都是该模块下的函数。

### intersperse

将前一个元素插入后面每一对元素中间

```haskell
ghci> intersperse '.' "abcdef"
-- => "a.b.c.d.e.f"
ghci> intersperse 0 [1,2,3,4,5,6]  
-- => [1,0,2,0,3,0,4,0,5,0,6]
```

### transpose

可以将嵌套的list行变为列

```haskell
ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]
-- => [[1,4,7],[2,5,8],[3,6,9]]  

ghci> transpose ["hey","there","guys"]
-- => ["htg","ehu","yey","rs","e"]

ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
-- => [18,8,6,17]
```

### foldl' foldl1'

fold在处理较大list时会出现堆栈溢出，此时可以使用 fold 的严格版本 foldl' 和 foldl1'

### concat

将嵌套的 list 铺平为一个list, 可以通过多次调用来铺平多层嵌套

```haskell
ghci> concat ["foo","bar","car"]  
-- => "foobarcar"
ghci> concat [[3,4,5],[2,3,4],[2,1,1]]  
-- => [3,4,5,2,3,4,2,1,1]
```

### concatMap

与 map 一个 List 之后再 concat 它等价

```haskell
ghci> concatMap (replicate 4) [1..3]  
[1,1,1,1,2,2,2,2,3,3,3,3]
```

### and

仅当list中的值都为True时，返回True

```haskell
ghci> and $ map (>4) [5,6,7,8]  
-- => True  
ghci> and $ map (==4) [4,4,4,3,4]  
-- => False
```

### or

如果list中包含True，就会返回True

```haskell
ghci> or $ map (==4) [2,3,4,5,6,1]  
-- => True
ghci> or $ map (>4) [1,2,3]  
-- => False
```

### any all

any list中有值都满足条件，就返回True  
all list中所有值都满足条件时返回True

```haskell
ghci> any (==4) [2,3,5,6,1,4]  
True  
ghci> all (>4) [6,9,10]  
True  
ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
False  
ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
True
```

### iterate

取一个函数和一个值作参数。它会用该值去调用该函数并用所得的结果再次调用该函数，产生一个无限的 List.

```haskell
ghci> take 10 $ iterate (*2) 1  
[1,2,4,8,16,32,64,128,256,512]  
ghci> take 3 $ iterate (++ "haha") "haha"  
["haha","hahahaha","hahahahahaha"]
```

### splitAt

```haskell
ghci> splitAt 3 "heyman"  
("hey","man")
ghci> splitAt 100 "heyman"  
("heyman","")  
ghci> splitAt (-3) "heyman"  
("","heyman")  
ghci> let (a,b) = splitAt 3 "foobar" in b ++ a  
"barfoo"
```

### takeWhile

从一个 List 中取元素，一旦遇到不符合条件的某元素就停止.

```haskell
ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]  
[6,5,4]  
ghci> takeWhile (/=' ') "This is a sentence"  
"This"

-- 求所有三次方小于 1000 的数的和
-- 无限 List 执行的 filter 永远都不会停止, 所有可以使用takeWhile
ghci> sum $ takeWhile (<10000) $ map (^3) [1..]  
53361
```

### dropWhile

如果list中的元素不满足条件，它就返回 List 的余下部分

```haskell
ghci> dropWhile (/=' ') "This is a sentence"  
" is a sentence"  
ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]  
[3,4,5,4,3,2,1]

-- Tuple 的首项表示股票价格，第二三四项分别表示年,月,日。我们想知道它是在哪天首次突破 $1000 的
ghci> let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]  
ghci> head (dropWhile (\(val,y,m,d) -> val < 1000) stock)  
(1001.4,2008,9,4)

```

### span break

与 takeWhile dropWhile 类似,只是它返回两个 List  
span 是在条件首次为 False 时断开 List，而 break 则是在条件首次为 True 时断开 List

```haskell
ghci> break (==4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
ghci> span (/=4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])
```

### group

取一个 List 作参数，并将其中相邻并相等的元素各自归类，组成一个个子 List.

```haskell
ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]

-- 将一个list中 相邻且相等的元素分组为多个子数组。

ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
```

### inits tails

与 init 和 tail 类似，只是他们会不断递归自己到什么都不剩。

```haskell
ghci> inits "w00t"  
["","w","w0","w00","w00t"]  
ghci> tails "w00t"  
["w00t","00t","0t","t",""]  
ghci> let w = "w00t" in zip (inits w) (tails w)  
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
```

### isInfixOf

类似 `elem` 只是第一个元素为 list

```haskell
ghci> "cat" `isInfixOf` "im a cat burglar"  
True  
ghci> "Cat" `isInfixOf` "im a cat burglar"  
False
```

### isPrefixOf 与 isSuffixOf

一个list 是否以另一个子list开头或结尾

```haskell
ghci> "hey" `isPrefixOf` "oh hey there!"  
False  
ghci> "there!" `isSuffixOf` "oh hey there!"  
True  
```

### elem 与 notElem

检查一个 List 是否包含或不包含某元素.

### partition

根据限制条件返回两个list,一个满足条件,一个不满足条件

```haskell
ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]  
([5,6,7],[1,3,3,2,1,0,3])
ghci> span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
("BOB","sidneyMORGANeddy")
```

### find

根据限制条件返回第一个满足条件的元素，这个元素是一个Maybe值，
Maybe 值可能是 Just something 或 Nothing

```haskell
ghci> find (>4) [1,2,3,4,5,6]  
Just 5  
ghci> find (>9) [1,2,3,4,5,6]  
Nothing  
ghci> :t find  
find :: (a -> Bool) -> [a] -> Maybe a
```

### elemIndex

类似find 和 elem 的合体， 只是返回和元素相等的第一个元素的index, 如果不存在返回Nothing

```haskell
ghci> :t elemIndex  
elemIndex :: (Eq a) => a -> [a] -> Maybe Int  
ghci> 4 `elemIndex` [1,2,3,4,5,6]  
Just 3  
ghci> 10 `elemIndex` [1,2,3,4,5,6]  
Nothing
```

### elemIndices

返回与元素相等的所有元素的index组成的list

```haskell
ghci> ' ' `elemIndices` "Where are the spaces?"  
[5,9,13]
```

### findIndex

与find类似，根据条件返回第一个符合的元素的index

```haskell
ghci> findIndex (==4) [5,3,2,1,6,4]  
Just 5  
ghci> findIndex (==7) [5,3,2,1,6,4]  
Nothing  
```

### findIndices

返回所有符合条件的元素的index组成的list

```haskell
ghci> findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"  
[0,6,10,14]
```

### zip3-7 zipWith3-7

与zip 和zipWith 类似，它们可以加3个到7个list合并到一个二元数组或二元函数中。

```haskell
ghci> zipWith3 (\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]  
[7,9,8]  
ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]
```

### lines unlines

lines 放回由换行符拆成的字符串的list  
unlines 返回和lines相反返回由list通过换行符拼接成的字符串

```haskell
ghci> lines "first line\nsecond line\nthird line"  
["first line","second line","third line"]
```

### words 和 unwords

把一个字串分为一组单词或执行相反的操作

```haskell
ghci> words "hey these are the words in this sentence"
["hey","these","are","the","words","in","this","sentence"]  
ghci> words "hey these are the words in this\nsentence"  
["hey","these","are","the","words","in","this","sentence"]  
ghci> unwords ["hey","there","mate"]  
"hey there mate"
```

### nub

将一个 List 中的重复元素去掉

```haskell
ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]  
[1,2,3,4]  
ghci> nub "Lots of words and stuff"  
"Lots fwrdanu"
```

### delete

删除list中首次出现的该元素。

```haskell
ghci> delete 'h' "hey there ghang!"  
"ey there ghang!"  
ghci> delete 'h' . delete 'h' $ "hey there ghang!"  
"ey tere ghang!"
```

### 函数 \\

类似集合的差积，返回不包含后面list中元素的list

```haskell
ghci> [1..10] \\ [2,5,9]  
[1,3,4,6,7,8,10]  
ghci> "Im a big baby" \\ "big"  
"Im a  baby"
```

### union

类似集合的并集，返回的list中都会包含后面的list

```haskell
ghci> "hey man" `union` "man what's up"  
"hey manwt'sup"  
ghci> [1..7] `union` [5..10]  
[1,2,3,4,5,6,7,8,9,10]
```

### intersection

交集，返回两个list的交集

```haskell
ghci> [1..7] `intersect` [5..10]  
[5,6,7]
```

### insert

insert 可以将一个元素插入一个可排序的 List，并将其置于首个大于等于它的元素之前,如果元素已经排序，返回接口也将是排序的

```haskell
ghci> insert 4 [1,2,3,5,6,7]  
[1,2,3,4,5,6,7]  
ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']  
"abcdefghijklmnopqrstuvwxyz"  
ghci> insert 3 [1,2,4,3,2,1]  
[1,2,3,4,3,2,1]
```

### 更多

length，take，drop，splitAt，!! 和 replicate 之类的函数有个共同点。那就是它们的参数中都有个 Int 值（或者返回Int值），我觉得使用 Intergal 或 Num 型别类会更好，但出于历史原因，修改这些会破坏掉许多既有的代码。在 Data.List 中包含了更通用的替代版，如: genericLength，genericTake，genericDrop，genericSplitAt，genericIndex 和 genericReplicate。  

length 的型别声明为 length :: [a] -> Int，而我们若要像这样求它的平均值，let xs = [1..6] in sum xs / length xs ，就会得到一个型别错误，因为 / 运算符不能对 Int 型使用! 而 genericLength 的型别声明则为 genericLength :: (Num a) => [b] -> a，Num 既可以是整数又可以是浮点数，let xs = [1..6] in sum xs / genericLength xs 这样再求平均数就不会有问题  

nub, delete, union, intsect 和 group 函数也有各自的通用替代版 nubBy，deleteBy，unionBy，intersectBy 和 groupBy，它们的区别就是前一组函数使用 (==) 来测试是否相等，而带 By 的那组则取一个函数作参数来判定相等性，group 就与 groupBy (==) 等价.  

```haskell
ghci> let values = [-4.3，-2.4，-1.2，0.4，2.3，5.9，10.5，29.1，5.3，-2.4，-14.5，2.9，2.3]  
ghci> groupBy (\x y -> (x > 0) == (y > 0)) values  
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]

-- 使用Data.Function 的on可以进一步简化
ghci> groupBy ((==) `on` (> 0)) values  
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]]
```

sort，insert，maximum 和 min 都有各自的通用版本。如 groupBy 类似，sortBy，insertBy，maximumBy 和 minimumBy 都取一个函数来比较两个元素的大小。像 sortBy 的型别声明为: sortBy :: (a -> a -> Ordering) -> [a] -> [a]。前面提过，Ordering 型别可以有三个值,LT，EQ 和 GT。compare 取两个 Ord 型别类的元素作参数，所以 sort 与 sortBy compare 等价.

```haskell
-- 可以根据list的长度来比较list的大小
ghci> let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]  
ghci> sortBy (compare `on` length) xs  
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]
```

## Data.Char

isControl 判断一个字符是否是控制字符。 isSpace 判断一个字符是否是空格字符，包括空格，tab，换行符等. isLower 判断一个字符是否为小写. isUper 判断一个字符是否为大写。 isAlpha 判断一个字符是否为字母. isAlphaNum 判断一个字符是否为字母或数字. isPrint 判断一个字符是否是可打印的. isDigit 判断一个字符是否为数字. isOctDigit 判断一个字符是否为八进制数字. isHexDigit 判断一个字符是否为十六进制数字. isLetter 判断一个字符是否为字母. isMark 判断是否为 unicode 注音字符，你如果是法国人就会经常用到的. isNumber 判断一个字符是否为数字. isPunctuation 判断一个字符是否为标点符号. isSymbol判断一个字符是否为货币符号. isSeperater 判断一个字符是否为 unicode 空格或分隔符. isAscii 判断一个字符是否在 unicode 字母表的前 128 位。 isLatin1 判断一个字符是否在 unicode 字母表的前 256 位. isAsciiUpper 判断一个字符是否为大写的 ascii 字符. isAsciiLower 判断一个字符是否为小写的 ascii 字符.  

以上所有判断函数的型别声明皆为 Char -> Bool，用到它们的绝大多数情况都无非就是过滤字串或类似操作

```haskell
ghci> all isAlphaNum "bobby283"  
True  
ghci> all isAlphaNum "eddy the fish!"  
False
```
