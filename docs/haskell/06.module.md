# 模块

## 加载模块

haskell 中使用 `import` 来加载模块，一般定义在代码顶部。
> Prelude 是haskell标准库的一组模块，它缺省自动加载

``` haskell
import Data.List  

numUniques :: (Eq a) => [a] -> Int  
numUniques = length . nub
```

也可以在ghci中使用 :m 加载模块

```haskell
ghci> :m Data.List Data.Map Data.Set
```

部分引入

```haskell
import Data.List (nub, sort)
```

除去部分函数引入其它部分

```haskell
import Data.List hiding (nub)
```

为避免命名冲突，可以有限制的引入, 同时为了使用简单可以加上别名

```haskell
import qualified Data.Map
-- 使用 Data.map.filter

import qualified Data.Map as M
-- 使用 M.filter
```

## Data.List

该主要是用来操作 list 的， 如之前使用过的map 和 filter 都是该模块下的函数。

### intersperse

将前一个元素插入后面每一对元素中间

```haskell
ghci> intersperse '.' "abcdef"
-- => "a.b.c.d.e.f"
ghci> intersperse 0 [1,2,3,4,5,6]  
-- => [1,0,2,0,3,0,4,0,5,0,6]
```

### transpose

可以将嵌套的list行变为列

```haskell
ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]
-- => [[1,4,7],[2,5,8],[3,6,9]]  

ghci> transpose ["hey","there","guys"]
-- => ["htg","ehu","yey","rs","e"]

ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
-- => [18,8,6,17]
```

### foldl' foldl1'

fold在处理较大list时会出现堆栈溢出，此时可以使用 fold 的严格版本 foldl' 和 foldl1'

### concat

将嵌套的 list 铺平为一个list, 可以通过多次调用来铺平多层嵌套

```haskell
ghci> concat ["foo","bar","car"]  
-- => "foobarcar"
ghci> concat [[3,4,5],[2,3,4],[2,1,1]]  
-- => [3,4,5,2,3,4,2,1,1]
```

### concatMap

与 map 一个 List 之后再 concat 它等价

```haskell
ghci> concatMap (replicate 4) [1..3]  
[1,1,1,1,2,2,2,2,3,3,3,3]
```

### and

仅当list中的值都为True时，返回True

```haskell
ghci> and $ map (>4) [5,6,7,8]  
-- => True  
ghci> and $ map (==4) [4,4,4,3,4]  
-- => False
```

### or

如果list中包含True，就会返回True

```haskell
ghci> or $ map (==4) [2,3,4,5,6,1]  
-- => True
ghci> or $ map (>4) [1,2,3]  
-- => False
```

### any all

any list中有值都满足条件，就返回True  
all list中所有值都满足条件时返回True

```haskell
ghci> any (==4) [2,3,5,6,1,4]  
True  
ghci> all (>4) [6,9,10]  
True  
ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
False  
ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
True
```

###　iterate

取一个函数和一个值作参数。它会用该值去调用该函数并用所得的结果再次调用该函数，产生一个无限的 List.

```haskell
ghci> take 10 $ iterate (*2) 1  
[1,2,4,8,16,32,64,128,256,512]  
ghci> take 3 $ iterate (++ "haha") "haha"  
["haha","hahahaha","hahahahahaha"]
```

### splitAt

```haskell
ghci> splitAt 3 "heyman"  
("hey","man")
ghci> splitAt 100 "heyman"  
("heyman","")  
ghci> splitAt (-3) "heyman"  
("","heyman")  
ghci> let (a,b) = splitAt 3 "foobar" in b ++ a  
"barfoo"
```

### takeWhile

从一个 List 中取元素，一旦遇到不符合条件的某元素就停止.

```haskell
ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]  
[6,5,4]  
ghci> takeWhile (/=' ') "This is a sentence"  
"This"

-- 求所有三次方小于 1000 的数的和
-- 无限 List 执行的 filter 永远都不会停止, 所有可以使用takeWhile
ghci> sum $ takeWhile (<10000) $ map (^3) [1..]  
53361
```

### dropWhile

如果list中的元素不满足条件，它就返回 List 的余下部分

```haskell
ghci> dropWhile (/=' ') "This is a sentence"  
" is a sentence"  
ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]  
[3,4,5,4,3,2,1]

-- Tuple 的首项表示股票价格，第二三四项分别表示年,月,日。我们想知道它是在哪天首次突破 $1000 的
ghci> let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]  
ghci> head (dropWhile (\(val,y,m,d) -> val < 1000) stock)  
(1001.4,2008,9,4)

```

### span break

与 takeWhile dropWhile 类似,只是它返回两个 List  
span 是在条件首次为 False 时断开 List，而 break 则是在条件首次为 True 时断开 List

```haskell
ghci> break (==4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
ghci> span (/=4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])
```

### group

取一个 List 作参数，并将其中相邻并相等的元素各自归类，组成一个个子 List.

```haskell
ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]

-- 若在 group 一个 List 之前给它排序就可以得到每个元素在该 List 中的出现次数。

ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
```

