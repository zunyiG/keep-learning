# 高阶函数

如果一个函数接收函数作为参数或者返回一个函数，我们称这样的函数为高阶函数。

## 科里化（curried）

本质上，haskell的所有函数都只有一个参数，所看到的多参数函数都是科里化函数

```haskell
ghci > max 4 5
=> 5

ghci > (max 4) 5
=> 5
```

把空格放到两个东西之间，我们称之为函数调用，它类似于运算符，并拥有最高优先级。  
max :: (Ord a) => a -> a -> a, 也可以写作 max :: (Ord a) => a -> (a -> a) 即max传入一个参数将返回一个函数  
这就是为什么用 -> 来分割参数和返回值  
这样的好处就是，可以极大的方便我们通过传入不完全的参数来构建新的函数。

```haskell
add_two = (+ 2)
ghci > add_two 1
=> 3

compareWithHundred = compare 100

isUpperCase = (`elem` ['A'..'Z'])
```

## 示例

### zipWith

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith' _ [] _ = []
zipWith' _ _ [] = []
zipWith' f (x: xs) (y: ys) = f x y : zipWith' f xs ys
```

函数的第一个参数是一个函数 第二、三个参数是一个list，  
并且第一个list的类型a必须和第一个函数参数的a相同，第二个list的类型b必须和第二个函数参数的b相同  
如果说第一个函数类型是 `a -> b -> c`，而传入的类型是 `a -> a -> c` 这样是可以的，但是反之就不行  

高阶函数拥有强大的抽象能力，只需简单的组合就可以发挥强大的作用

``` haskell
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci> zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
ghci> zipWith' (++) ["foo "，"bar "，"baz "] ["fighters"，"hoppers"，"aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
ghci> zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]
```

### flip

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)  
flip' f = g  
    where g x y = f y x
```

由于haskell中函数都是科里化的， 所以 `(a -> b -> c) -> (b -> a -> c)` 等价于 `(a -> b -> c) -> (b -> (a -> c))`  
就等价于 `(a -> b -> c) -> b -> a -> c`, 所以我们也可以写成：

```haskell
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f y x = f x y
```

```haskell
ghci> flip' zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]  
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]  
[5,4,3,2,1]
```

## map 与 filter

map 取一个函数和 List 做参数，遍历该 List 的每个元素来调用该函数产生一个新的 List

```haskell
map :: (a -> b) -> [a] -> [b]  
map _ [] = []  
map f (x:xs) = f x : map f xs
```

它其实与 List Comprehension 有相似之处，map (+3) [1,5,3,1,6] 与 [x+3 | x <- [1,5,3,1,6] 完全等价。

filter 函数取一个限制条件和一个 List，回传该 List 中所有符合该条件的元素

```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter f (x: xs)
  | f x       = x : filter f xs
  | otherwise = filter f xs
```

什么情况下用 map 和 filter 还是 List Comprehension，选择权归你，看谁舒服用谁就是。 如果有多个限制条件，只能连着套好几个 filter 或用 && 等逻辑函数的组合之，这时就不如 List comprehension 来得爽了  
  
quickSort 的 filter写法

```haskell
quicksort :: (Ord a) => [a] -> [a]
quicksort [] = []
quicksort (x: xs) =
  let smallerSorted = quicksort (filter (<= x) xs)
      biggerSorted = quicksort (filter (> x) xs)
  in smallerSorted ++ [x] ++ biggerSorted
```

更多用法

```haskell
largestDivisible :: (Integral a) => a  
largestDivisible = head (filter p [100000,99999..])  
    where p x = x `mod` 3829 == 0
```

takeWhile 它取一个限制条件和 List 作参数，然后从头开始遍历这一 List，并返回符合限制条件的元素。 而一旦遇到不符合条件的元素，就停止。  
求所有小于 10000 的奇数的平方的和:

```haskell
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
=> 166650
```

Collatz序列 取一个自然数，若为偶数就除以 2。 若为奇数就乘以 3 再加 1。 再用相同的方式处理所得的结果，得到一组数字构成的的链。它有个性质，无论任何以任何数字开始，最终的结果都会归 1。

```haskell
collatz_chain :: (Integral a) => a -> [a]
collatz_chain 1 = [1]
collatz_chain n
  | odd n = n : collatz_chain (n * 3 + 1)
  | otherwise = n : collatz_chain (n `div` 2)

numLongChains :: Int  
numLongChains = length (filter isLong (map chain [1..100]))  
    where isLong xs = length xs > 15
```

```haskell
ghci> let listOfFuns = map (*) [0..]  
ghci> (listOfFuns !! 4) 5  
20
```

取所得 List 的第五个元素可得一函数，与 (*4) 等价。 然后用 5 调用它，与 (* 4) 5 或 4*5 都是等价的.

## lambda （匿名函数）

lambda 就是匿名函数。有些时候我们需要传给高阶函数一个函数，而这函数我们只会使用这一次

```haskell
ghci > (\ x -> x + 1) 1
=> 2
```

不熟悉科里化往往会写出一些没必要的 lambda。  
例如，表达式 `map (+3) [1,6,3,2]` 与 `map (\x -> x+3) [1,6,3,2]` 等价, 所以上面的可以改成：

```haskell
ghci > (+ 1) 1
=> 2
```

lambda 也可以取多个参数。

```haskell
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  
[153.0,61.5,31.0,15.75,6.6]
```

可以在 lambda 中使用模式匹配, lambda 的模式匹配若失败，就会引发一个运行时错误，所以慎用！

```haskell
ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[3,8,9,8,7]
```

一般情况下，lambda 都是括在括号中，除非我们想要后面的整个语句都作为 lambda 的函数体。很有趣，由于有柯里化，如下的两段是等价的：

```haskell
addThree :: (Num a) => a -> a -> a -> a  
addThree x y z = x + y + z

addThree :: (Num a) => a -> a -> a -> a  
addThree = \x -> \y -> \z -> x + y + z
```

## fold
